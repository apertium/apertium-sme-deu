!!!!!!!!!!!!!!!
!! ATTRIBUTE CATEGORIES
!!!!!!!!!!!!!!!

number = (ND sg) sg pl sp du ND ;
gender = (GD m) m f mf nt mfn GD ;
case = (CD nom) nom acc dat gen ill loc com ess CD ;
det_type = def ind dem itg pos qnt ;
tense = pres fut pret pii imp ;
person = p1 p2 p3 ;
npclass = ant org al top geo;
prntype = pers ind qnt itg dem pos;
sep = sep ;
fs = fs ;
advtype = itg ;
inf = inf actio ;
pcp = pp pprs prfprc ;
finity = (FIN fin) inf actio pp prs pprs prfprc fin ;
conneg = conneg ;
def = ind def ;
adj_type = sint pred attr ;
negativity = (NEG aff) neg aff ;
comparison = comp sup ;
! Giella specifics
sem = (SEM sem_dummy) sem_time sem_plc sem_hum sem_ani sem_dummy ;
depfunc = "@←SPRED" "@←OPRED" "@←N" "@HNOUN" ;

!!!!!!!!!!!!!!!
!! OUTPUT PATTERNS
!!!!!!!!!!!!!!!

! single words
n: _.gender.number.case;
np: _.npclass.gender.number.case;
adj: _.gender.number;
vblex_fin: _.sep.fs.tense.person.number;
vblex_inf: _.sep.inf;
vblex_pp: _.sep.pcp;
vbser: _.tense.person.number;
vbmod: _.tense.person.number;
cnjcoo: _;
cnjsub: _;
prn: _.prntype.person.gender.number.case;
det: _.det_type.person.gender.number.case;
det_pos: _.det_type.gender.number.case;
adv: _.advtype;
post: _;
pr: _;
adj_agr: _.<sint>.comparison.gender.number.case.<st>;
adj_pred: _.<sint>.adj_type;
num: _.number;
pcle: _;

! smaller phrases
PROPN: _.case ;
N: _.gender.number.case.sem ;
V: _.number.person ;
C: _;
PRN: _.case.number.person;
DET: _.gender.case.number.person;
ADV: _;
ADP: _;
A: _.comparison.gender.number.case ;
NUM: _ ;
VP: _.negativity ;
NEG: _ ;
S: _ ;

! phrases

PP: _ ;
NUMP: _.number.case ;
NP: _.gender.number.case.sem;
DP: _.gender.number.case;


!!!!!!!!!!!!!!!
!! TAG-REWRITE RULES
!!!!!!!!!!!!!!!

tense > tense : pret pii, pres pri, fti fut;
! case > case : ill dat, loc dat, com dat, ess nom;
! number > number : du pl ;
inf > inf : actio inf ;
pcp > pcp : prfprc pp ;
conneg > person : conneg p3 ;
conneg > number : conneg sg ;

!!!!!!!!!!!!!!!
!! MACROS
!!!!!!!!!!!!!!!

maybe_art: (if (1.number = sg)
                (if (1.def = def)
                    (if (1.case = com) [der@det.def.[1.gender].sg.dat _]
                     elif (1.case = ill) [der@det.def.[1.gender].sg.acc _]
                     elif (1.case = loc) [der@det.def.[1.gender].sg.dat _]
                     elif (1.case = ess) [der@det.def.[1.gender].sg.nom _]
                     else [der@det.def.[1.gender].sg.[1.case] _ ])
                else
                    (if (1.negativity = neg)
                        (if (1.case = com) [kein@det.ind.[1.gender].sg.dat _]
                         elif (1.case = ill) [kein@det.ind.[1.gender].sg.acc _]
                         elif (1.case = loc) [kein@det.ind.[1.gender].sg.dat _]
                         elif (1.case = ess) [kein@det.ind.[1.gender].sg.nom _]
                         else [kein@det.ind.[1.gender].sg.[1.case] _ ])
                    else
                        (if (1.case = com) [ein@det.ind.[1.gender].sg.dat _]
                         elif (1.case = ill) [ein@det.ind.[1.gender].sg.acc _]
                         elif (1.case = loc) [ein@det.ind.[1.gender].sg.dat _]
                         elif (1.case = ess) [ein@det.ind.[1.gender].sg.nom _]
                         else [ein@det.ind.[1.gender].sg.[1.case] _ ])
                    )
                )
            else
                (if (1.def = def) 
                    (if (1.case = com) [der@det.def.mfn.pl.dat _]
                     elif (1.case = ill) [der@det.def.mfn.pl.dat _]
                     elif (1.case = loc) [der@det.def.mfn.pl.acc _]
                     elif (1.case = ess) [der@det.def.mfn.pl.nom _]
                     else [der@det.def.mfn.pl.[1.case] _])
                else 
                    (if (1.negativity = neg)
                        (if (1.case = com) [kein@det.ind.[1.gender].sg.dat _]
                         elif (1.case = ill) [kein@det.ind.[1.gender].sg.acc _]
                         elif (1.case = loc) [kein@det.ind.[1.gender].sg.dat _]
                         elif (1.case = ess) [kein@det.ind.[1.gender].sg.nom _]
                         else [kein@det.ind.[1.gender].sg.[1.case] _ ])
                    else []
                    )
                )
            );
maybe_adp: (if (1.case = loc) [in@pr.dat _]
            elif (1.case = ill) [in@pr.acc _]
            elif (1.case = com) [mit@pr.dat _]
            elif (1.case = ess) [wie@pr.nom _]  !! als?
            elif (1.case = dat) [zu@pr.dat _]
            else []) ;
pro_undrop: (if (1.number = sg)
                (if (1.person = p1) [ich@prn.pers.p1.mf.sg.nom _]
                 elif (1.person = p2) [du@prn.pers.p2.mf.sg.nom _]
                 elif (1.person = p3) []  !! no undrop 3.sg?
                 else [$$expletive _])
             elif (1.number = pl)
                (if (1.person = p1) [wir@prn.pers.p1.mf.pl.nom _]
                 elif (1.person = p2) [ihr@prn.pers.p2.mf.pl.nom _]
                 elif (1.person = p3) [sie@prn.pers.p3.mf.pl.nom _]
                 else [$$expletive _])
             elif (1.number = du)
                (if (1.person = p1) [wir@prn.pers.p1.mf.pl.nom _ beide@det.ind.mfn.pl.nom _]
                 elif (1.person = p2) [ihr@prn.pers.p2.mf.pl.nom _ beide@det.ind.mfn.pl.nom _]
                 elif (1.person = p3) [sie@prn.pers.p3.mf.pl.nom _ beide@det.ind.mfn.pl.nom _]
                 else [$$expletive _])
             else [$$expletive _]) ;
maybe_nicht: (if (1.negativity = neg) [nicht@adv _]
              else []) ; 
!! split pos generation fucntions
adj: (if (1.depfunc = "@←SPRED") 1(adj_pred)[adj_type=pred]
      elif (1.depfunc = "@←OPRED") 1(adj_pred)[adj_type=pred]
      else 1(adj_agr)
     ) ;
vblex: (if (1.finity = inf) 1(vblex_inf)
        elif (1.finity = actio) 1(vblex_inf)[inf=inf]  ! probably not ideal
        elif (1.pcp = pp) 1(vblex_pp)
        elif (1.pcp = prfprc) 1(vblex_pp)  ! probably not ideal
        elif (1.pcp = pprs) 1(vblex_pp)
        else 1(vblex_fin) ) ;

!!!!!!!!!!!!!!!
!! REDUCTION RULES
!!!!!!!!!!!!!!!
S -> C PRN.loc leat@vblex NP { 1 _ 2 _ 
            *(maybe_adp)[case=4.case]
            *(maybe_art)[number=4.number,case=4.case,gender=4.gender,def=ind,negativity=3.negativity]
            4 _ 
            haben@vbhaver.pri.[2.person].[2.number] } |
    ADV VP NP { 2 _ 1 _
        *(maybe_adp)[case=3.case]
        *(maybe_art)[number=3.number,case=3.case,gender=3.gender,def=ind,negativity=2.negativity]
        3 } |
     VP NP { 1 _
        *(maybe_adp)[case=2.case]
        *(maybe_art)[number=2.number,case=2.case,gender=2.gender,def=ind,negativity=1.negativity]
        2 } |
     VP DP { 1 _ 
        *(maybe_adp)[case=2.case]
        *(maybe_nicht)[negativity=1.negativity]
        2 } |
     VP { 1 _ *(maybe_nicht)[negativity=1.negativity] } |  ! stray VP
     NP {
        *(maybe_adp)[case=1.case]
        *(maybe_art)[number=1.number,case=1.case,gender=1.gender,def=def,negativity=aff]
        1 } |
     DP {
        *(maybe_adp)[case=1.case]
        1 } |
     PROPN {
        *(maybe_adp)[case=1.case]
        1 } ; ! stray PROPN (no article)
NEG -> ii@vblex { nicht@adv[lemcase=1.lemcase] } ; ! stray NEG
VP -> NP.*.loc.sem_hum leat@vblex {
        *(maybe_adp)[case=nom]
        *(maybe_art)[number=1.number, case=nom, gender=1.gender,def=def,negativity=aff] 
        1[case=nom] _ haben@vbhaver.pri.p3.[1.number] } |
      leat@vblex go@pcle PRN.*.loc {
        haben@vbhaver.pri.[3.person].[3.number] _
        3[case=nom] } |
      %PROPN.*.loc leat@vblex {
        *(maybe_adp)[case=nom]
        %1[case=nom] _ haben@vbhaver.pri.p3.sg } |
      PRN.*.loc leat@vblex {
        *(maybe_adp)[case=nom]
        1[case=nom] _ haben@vbhaver.pri.[1.person].[1.number] } |
      PRN.*.loc ADV leat@vblex {
        2 _ 
        *(maybe_adp)[case=nom]
        1[case=nom] _ haben@vbhaver.pri.[1.person].[1.number] } |
      DET.*.loc leat@vblex {
        *(maybe_adp)[case=nom]
        1[case=nom] _ haben@vbhaver.pri.[1.person].[1.number] } |
      ii@vblex DP.*.loc leat@vblex {
        nicht@adv _
        *(maybe_adp)[case=nom]
        2[case=nom] _ haben@vbhaver.pri.[1.person].[2.number] } |
      DP.*.loc leat@vblex {
        *(maybe_adp)[case=nom]
        1[case=nom] _ haben@vbhaver.pri.[1.person].[1.number] } |
      NP V {
        *(maybe_adp)[case=1.case]
        *(maybe_art)[number=1.number, case=1.case, gender=1.gender,def=def,negativity=aff]
        1 _ 2 } |
      PRN V {
        *(maybe_adp)[case=1.case]
        1 _ 2 } |
      PRN ADV V {
        *(maybe_adp)[case=1.case]
        1 _ 3 _ 2 } |
      PROPN V {
        *(maybe_adp)[case=1.case]
        1 _ 2 } |
      DP V {
        *(maybe_adp)[case=1.case]
        1 _ 2 } |
      PRN ii@vblex vblex [$negativity=neg] { 1 _
        3[person=2.person,number=2.number] } |
      ii@vblex vblex [$negativity=neg] {
        *(pro_undrop)[number=1.number,person=1.person]
        2[person=1.person, number=1.number] } |
      ii@vblex prn vblex [$negativity=neg] {
        2 _ 3[person=1.person, number=1.number] } |
      V go@pcle {
      1 _ *(pro_undrop)[number=1.number,person=1.person] } |  ! stray V + qst
      V { *(pro_undrop)[number=1.number,person=1.person] 1 } ;  ! stray V
V -> %vblex [$$expletive=(if (1.lem = "regnen") es@prn.pers.p3.nt.sg.nom),
             $person = (if (1.tense = imp) ""
                         elif (1.lem = "regnen") ""
                         else 1.person)]
            {1[person = (if (1.tense = imp) "" else 1.person),
               number = (if (1.number = du) pl else 1.number)] } |
     %vbser {1} |
     %vbmod {1} ;
PP -> NUMP post { 2 _ 1 } |
      ! idioms
      prn.pers.*.gen.* mielas@post { 1 _ Meinung@n.f.sg.nom _ nach@pr.dat } |
      PRN post { 2 _ 1 } |
      NP post { 2 _ 1 } ;
NUMP -> ! if number is one: use indefinite article instead and singulars:
        %num A n ?(1.lem/sl = "okta") { 
            eine@det.ind.[3.gender].[3.number].[3.case] _
                 %2[number=sg,case=1.case] _
                 %3[number=sg,case=1.case] } |
        %num A n { 1[number=pl,gender=3.gender] _
                 %2[number=pl,case=1.case] _
                 %3[number=pl,case=1.case] } |
        %num n ?(1.lem/sl = "okta") { 
            eine@det.ind.[2.gender].[2.number].[2.case] _
            %2[number=sg,case=1.case] } | 
        %num n { 1[number=pl,gender=2.gender] _
                 %2[number=pl,case=1.case] } ;
NP -> A %N ADV { 1[gender=2.gender,
                   number=2.number,case=2.case] _ %2 _ 3 } |
      A %N { 1[gender=2.gender,
                 number=2.number,case=2.case] _ %2 } |
      %N ADV { %1 _ 2 } |
      N.*.gen N { %2 _ der@det.def.[1.gender].sg.gen _ 1 } |
      N.*.gen A N { 2 _ %3 _
                    der@det.def.[1.gender].sg.gen _ 1 } |
      ! idiomatic 1:n translations
      ! n
      %N { %1 } ;
DP -> DET %N { 1[gender=(if (2.number = pl) mfn else 2.gender),
                 number=2.number,
                 case=(if (2.case = loc) nom else 2.case)] _ 2 } |
      ! idiomatic 1:n translations
      ollu@adj %N { viel@adj.sint.attr _ 2 } | 
      veahkki@n { zu@pr.dat _ Hilfe@n.f.sg.dat } |
      ruhta@n { 1 } |
      ! det
      %DET { %1 } ;
N ->
    ! idioms
    ruhtadilli@n { finanziell@adj.sint.f.sg.nom.sw _ Situation@n.f.sg.nom } |
    ! normal n
    %n {1[case=(if (1.case = loc) acc
                                         elif (1.case = ill) dat
                                         elif (1.case = ess) nom
                                         elif (1.case = com) dat
                                         elif (1.case = acc) acc
                                         elif (1.case = dat) dat
                                         elif (1.case = gen) 
                                            (if (1.sem = sem_time) acc
                                            else gen)
                                         else nom),
                                   number=(if (1.number = du) pl
                                           elif (1.number = pl) pl
                                           else sg)] } ;
PROPN -> %np.* {%1} ;
C -> cnjcoo {1} |
     cnjsub {1} ;
DET -> %prn.pers.*.gen."@→N" { %1(det_pos) } |  ! Obs: list from sme-nob
       %prn.pers.*.gen."@→A" { %1(det_pos) } |
       %prn.pers.*.gen.*."@→N" { %1(det_pos) } |
       %prn.pers.*.gen.*."@→A" { %1(det_pos) } |
       %prn.ref.gen.*."@→N" { %1 } |
       %prn.ref.gen.*."@→A" { %1 } |
       %prn.ref.gen."@→N" { %1 } |
       %prn.ref.gen."@→A" { %1 } |
       %prn.dem.*."@→N" { %1 } |
       %prn.dem.*."@→A" { %1 } |
       %prn.ind.*."@→N" { %1 } |
       %prn.ind.*."@→A" { %1 } |
       %prn.itg.*."@→N" { %1 } |
       %prn.itg.*."@→A" { %1 } |
       %prn.ind."@→N" { %1 } |
       %prn.ind."@→A" { %1 } |
       %det { %1 } ;
PRN -> %prn { 1[case=(if (1.case = loc) nom
                     elif (1.case = ill) dat
                     elif (1.case = ess) nom
                     elif (1.case = com) dat
                     elif (1.case = acc) acc
                     elif (1.case = dat) dat
                     elif (1.case = gen) gen
                     else nom)] } ;
ADV -> adv {1} |
       ! idiomatics
       dáidit@vblex { vielleicht@adv } |
       davvin@adv { in@pr.dat Nord@n.m.pl.dat } |
       lulde@adv { in@pr.dat Süd@n.m.pl.dat } |
       pcle {1} ;
ADP -> post {1} |
       pr {1} ;
A -> %buorre@adj { %1[case=(if (1.case = loc) nom
                     elif (1.case = ill) dat
                     elif (1.case = ess) nom
                     elif (1.case = com) acc
                     elif (1.case = acc) acc
                     elif (1.case = dat) dat
                     elif (1.case = gen) gen
                     else nom)] } |
    %adj { %1 } ;
NUM -> num {1[number = (if (1.lem/sl = "okta") sg else pl)] } ;

    ! IE numerals have no morphological num so they assume semantic num

! Resources:
! https://wiki.apertium.org/wiki/Apertium-recursive
! https://wiki.apertium.org/wiki/Apertium-recursive/Formalism
! https://wiki.apertium.org/wiki/Apertium-recursive/Cookbook
