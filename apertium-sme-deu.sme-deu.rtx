!!!!!!!!!!!!!!!
!! ATTRIBUTE CATEGORIES
!!!!!!!!!!!!!!!

number = sg pl sp du ;
gender = m f mf nt mfn ;
case = nom acc dat gen ill loc com ess;
det_type = def ind dem itg;
tense = pres fut pret pii imp;
person = p1 p2 p3 ;
npclass = ant org al top geo;
prntype = pers ind itg;
sep = sep ;
fs = fs ;
advtype = itg ;
inf = inf actio ;
pcp = pp pprs prfprc ;
conneg = conneg ;

!!!!!!!!!!!!!!!
!! OUTPUT PATTERNS
!!!!!!!!!!!!!!!

! single words
n: _.gender.number.case;
np: _.npclass.gender.number.case;
adj: _.gender.number;
det_default: _.det_type;
det_def: _.det_type.number;
vblex: _.sep.inf.pcp.fs.tense.person.number;
vbser: _.tense.person.number;
vbmod: _.tense.person.number;
cnjcoo: _;
cnjsub: _;
prn: _.prntype.person.gender.number.case;
det: _.prntype.person.gender.number.case;
adv: _.advtype;
post: _;
pr: _;
adj: _.<sint>;
num: _.number;
pcle: _;

! smaller phrases
PROPN: _.case ;
N: _.gender.number.case ;
V: _.number.person ;
C: _;
PRNP: _.case.number.person;
ADV: _;
ADP: _;
A: _ ;
NUM: _ ;
VP: _ ;
NEG: _ ;
S: _ ;

! phrases

PP: _ ;
NUMP: _ ;
NP: _.gender.number.case;

!!!!!!!!!!!!!!!
!! TAG-REWRITE RULES
!!!!!!!!!!!!!!!

tense > tense : pret pii, pres pri, fti fut;
! case > case : ill dat, loc dat, com dat, ess nom;
number > number : du pl ;
inf > inf : actio inf ;
pcp > pcp : prfprc pp ;
conneg > person : conneg p3 ;
conneg > number : conneg sg ;

!!!!!!!!!!!!!!!
!! MACROS
!!!!!!!!!!!!!!!

maybe_art: (if (1.number = sg)
                (if (1.case = com) [der@det.def.[1.gender].sg.dat _]
                 elif (1.case = ill) [der@det.def.[1.gender].sg.acc _]
                 elif (1.case = loc) [der@det.def.[1.gender].sg.dat _]
                 elif (1.case = ess) [der@det.def.[1.gender].sg.nom _]
                 elif (1.case = acc) [der@det.def.[1.gender].sg.acc _]
                 else [der@det.def.[1.gender].sg.nom _ ])
            else 
                (if (1.case = com) [der@det.def.mfn.pl.dat _]
                 elif (1.case = ill) [der@det.def.mfn.pl.dat _]
                 elif (1.case = loc) [der@det.def.mfn.pl.acc _]
                 elif (1.case = ess) [der@det.def.mfn.pl.nom _]
                 elif (1.case = acc) [der@det.def.mfn.pl.acc _]
                 else [der@det.def.mfn.pl.[1.case] _])
            );
maybe_adp: (if (1.case = loc) [in@pr.dat _]
            elif (1.case = ill) [in@pr.acc _]
            elif (1.case = com) [mit@pr.dat _]
            elif (1.case = ess) [wie@pr.nom _]  !! als?
            elif (1.case = dat) [zu@pr.dat _]
            else []) ;
pro_undrop: (if (1.number = sg)
                (if (1.person = p1) [ich@prn.pers.p1.mf.sg.nom _]
                 elif (1.person = p2) [du@prn.pers.p2.mf.sg.nom _]
                 elif (1.person = p3) [sie@prn.pers.p3.mf.sg.nom _]
                 else [$$expletive _])
             elif (1.number = pl)
                (if (1.person = p1) [wir@prn.pers.p1.mf.pl.nom _]
                 elif (1.person = p2) [ihr@prn.pers.p2.mf.pl.nom _]
                 elif (1.person = p3) [sie@prn.pers.p3.mf.pl.nom _]
                 else [$$expletive _])
             elif (1.number = du)
                (if (1.person = p1) [wir@prn.pers.p1.mf.pl.nom _ beide@det.ind.mfn.pl.nom _]
                 elif (1.person = p2) [ihr@prn.pers.p2.mf.pl.nom _ beide@det.ind.mfn.pl.nom _]
                 elif (1.person = p3) [sie@prn.pers.p3.mf.pl.nom _ beide@det.ind.mfn.pl.nom _]
                 else [$$expletive _])
             else [$$expletive _]) ;

!!!!!!!!!!!!!!!
!! REDUCTION RULES
!!!!!!!!!!!!!!!
S -> VP NP { 1 _
        *(maybe_adp)[case=2.case]
        *(maybe_art)[number=2.number,case=2.case,gender=2.gender]
        2 } |
     VP { 1 } |  ! stray VP
     NP {
        *(maybe_adp)[case=1.case]
        *(maybe_art)[number=1.number,case=1.case,gender=1.gender]
     1 } |
     PROPN {
        *(maybe_adp)[case=1.case]
        1 } ; ! stray PROPN (no article)
NEG -> ii@vblex { nicht@adv[lemcase=1.lemcase] } ; ! stray NEG
VP -> NP.*.loc leat@vblex {
        *(maybe_adp)[case=nom]
        *(maybe_art)[number=1.number, case=nom, gender=1.gender] 
        1[case=nom] _ haben@vbhaver.pri.[2.person].[2.number] } |
      PROPN.*.loc leat@vblex {
        *(maybe_adp)[case=nom]
        1[case=nom] _ haben@vbhaver.pri.[2.person].[2.number] } |
      PRNP.*.loc leat@vblex {
        *(maybe_adp)[case=nom]
        1[case=nom] _ haben@vbhaver.pri.[1.person].[1.number] } |
      NP V {
        *(maybe_adp)[case=1.case]
        *(maybe_art)[number=1.number, case=1.case, gender=1.gender]
        1 _ 2 } |
      PRNP V {
        *(maybe_adp)[case=1.case]
        1 _ 2 } |
      PROPN V {
        *(maybe_adp)[case=1.case]
        1 _ 2 } |
      ii@vblex vblex {
        2[person=1.person, number=1.number] _ nicht@adv } |
      ii@vblex prn vblex {
        2 _ 3[person=1.person, number=1.number] _ nicht@adv } |
      V go@pcle { 
      1 _ *(pro_undrop)[number=1.number,person=1.person] } |  ! stray V + qst
      V { *(pro_undrop)[number=1.number,person=1.person] 1 } ;  ! stray V
V -> %vblex [$$expletive=(if (1.lem = "regnen") es@prn.pers.p3.nt.sg.nom),
             $person = (if (1.tense = imp) ""
                         elif (1.lem = "regnen") ""
                         else 1.person)]
            {1[person = (if (1.tense = imp) "" else 1.person)] } |
     %vbser {1} |
     %vbmod {1} ;
PP -> NUMP post { 2 _ 1 } ;
NUMP -> num NP { 1[number=(if (1.lem/sl = "okta") sg else pl)] _
                 2[number=(if (1.lem/sl = "okta") sg else pl)] } ;
NP -> A %N { 1 _ 2 }|
      %N { 1 } ;
N -> n.$case/sl.$number.$gender/tl {1[case=(if (1.case = loc) acc
                                         elif (1.case = ill) dat
                                         elif (1.case = ess) nom
                                         elif (1.case = com) dat
                                         elif (1.case = acc) acc
                                         elif (1.case = dat) dat
                                         else nom),
                                   number=(if (1.number = du) pl
                                           elif (1.number =pl) pl
                                           else sg)] } ;
PROPN -> np.$case/sl.$number.$gender {1} ;
C -> cnjcoo {1} |
     cnjsub {1} ;
PRNP -> %prn { 1[case=(if (1.case = loc) acc
                     elif (1.case = ill) dat
                     elif (1.case = ess) nom
                     elif (1.case = com) dat
                     elif (1.case = acc) acc
                     elif (1.case = dat) dat
                     else nom)] } |
        %det {1} ;
ADV -> adv {1} |
       pcle {1} ;
ADP -> post {1} |
       pr {1} ;
A -> adj {1} ;
NUM -> num {1[number = (if (1.lem/sl = "okta") sg else pl)] } ; 
    ! IE numerals have no morphological num so they assume semantic num

! Resources:
! https://wiki.apertium.org/wiki/Apertium-recursive
! https://wiki.apertium.org/wiki/Apertium-recursive/Formalism
! https://wiki.apertium.org/wiki/Apertium-recursive/Cookbook
