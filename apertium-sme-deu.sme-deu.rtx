!!!!!!!!!!!!!!!
!! ATTRIBUTE CATEGORIES
!!!!!!!!!!!!!!!

number = sg pl sp du ;
gender = m f mf nt mfn ;
case = nom acc dat gen ill loc com ess;
det_type = def ind dem itg;
tense = pres fut pret pii imp;
person = p1 p2 p3 ;
npclass = ant org al top geo;
prntype = pers ind itg;
sep = sep ;
fs = fs ;
advtype = itg ;
inf = inf actio ;
pcp = pp pprs prfprc ;
conneg = conneg ;

!!!!!!!!!!!!!!!
!! OUTPUT PATTERNS
!!!!!!!!!!!!!!!

! single words
n: _.gender.number.case;
np: _.npclass.gender.number.case;
adj: _.gender.number;
det_default: _.det_type;
det_def: _.det_type.number;
vblex: _.inf.pcp.sep.fs.tense.person.number;
vbser: _.tense.person.number;
vbmod: _.tense.person.number;
cnjcoo: _;
cnjsub: _;
prn: _.prntype.person.gender.number.case;
det: _.prntype.person.gender.number.case;
adv: _.advtype;
post: _;
pr: _;
adj: _.<sint>;
num: _.number;
pcle: _;

! smaller phrases
PROPN: _ ;
N: _.gender.number.case ;
V: _;
C: _;
PRNP: _;
ADV: _;
ADP: _;
A: _ ;
NUM: _ ;
VP: _ ;
NEG: _ ;
S: _ ;

! phrases

PP: _ ;
NUMP: _ ;
NP: _.case;

!!!!!!!!!!!!!!!
!! TAG-REWRITE RULES
!!!!!!!!!!!!!!!

tense > tense : pret pii, pres pri, fti fut;
case > case : ill dat, loc dat, com dat, ess nom;
number > number : du pl ;
inf > inf : actio inf ;
pcp > pcp : prfprc pp ;
conneg > person : conneg p3 ;
conneg > number : conneg sg ;

!!!!!!!!!!!!!!!
!! MACROS
!!!!!!!!!!!!!!!

maybe_art: (if (1.number = sg) [der@det.def.[1.gender].sg.[1.case] _]
            else [der@det.def.mfn.pl.[1.case] _]) ;
maybe_adp: (if (1.case = loc) [in@pr.acc _] elif (1.case/sl = acc) [zu@pr.dat _] else []) ;

!!!!!!!!!!!!!!!
!! REDUCTION RULES
!!!!!!!!!!!!!!!
S -> VP NP { 1 _
        *(maybe_adp)[case=2.case]
        *(maybe_art)[number=2.number, case=2.case, gender=2.gender]
        2 } |
     VP { 1 } |  ! stray VP
     NP {
     *(maybe_adp)[case=1.case]
     *(maybe_art)[number=1.number,case=1.case,gender=1.gender]
     1 } ; ! stray NP
NEG -> ii@vblex { nicht@adv } ; ! stray NEG
VP -> NP.loc leat@vblex {
        *(maybe_adp)[case=nom]
        *(maybe_art)[number=1.number, case=nom, gender=1.gender] 
        1 _ haben@vbhaver.pri.[2.person].[2.number] } |
      NP V {
      *(maybe_adp)[case=1.case]
      *(maybe_art)[number=1.number, case=1.case, gender=1.gender]
      1 _ 2 } |
      ii@vblex vblex { 2[person=1.person, number=1.number] _ nicht@adv } |
      ii@vblex prn vblex { 2 _ 3[person=1.person, number=1.number] _ nicht@adv } |
      V { 1 } ;  ! stray V
V -> vblex {1[person = (if (1.tense = imp) "" else 1.person)]} |
     vbser {1} |
     vbmod {1} ;
PP -> NUMP post { 2 _ 1 } ;
NUMP -> num N { 1[number=(if (1.lem/sl = "okta") sg else pl)] _
                2[number=(if (1.lem/sl = "okta") sg else pl)] } ;
NP -> %N { 1 } ;
N -> %n { 1 } ;
PROPN -> np {1} ;
C -> cnjcoo {1} |
     cnjsub {1} ;
PRNP -> prn {1} |
        det {1} ;
ADV -> adv {1} |
       pcle {1} ;
ADP -> post {1} |
       pr {1} ;
A -> adj {1} ;
NUM -> num {1[number = (if (1.lem/sl = "okta") sg else pl)] } ; 
    ! IE numerals have no morphological num so they assume semantic num

! Resources:
! https://wiki.apertium.org/wiki/Apertium-recursive
! https://wiki.apertium.org/wiki/Apertium-recursive/Formalism
! https://wiki.apertium.org/wiki/Apertium-recursive/Cookbook
